
# # -*- coding: utf-8 -*-

# import rospy
# import math
# import random
# import message_filters
# from sensor_msgs.msg import Image, CameraInfo
# from cv_bridge import CvBridge,CvBridgeError
# import cv2
# from Stitcher import Stitcher
# import time


# stitcher = Stitcher() 
# feature = False

# def multi_callback(img_gx, img_hk):
#     try:
#         bridge1 = CvBridge()
#         gx_img = bridge1.imgmsg_to_cv2(img_gx, 'bgr8')
#         hk_img = bridge1.imgmsg_to_cv2(img_hk, 'bgr8')
#         print("同步完成！")
        
#         if feature:
#             final = stitcher.stitch([gx_img, hk_img], showMatches=True)
#         else:
#             final = stitcher.ORB_stitch_images(hk_img,gx_img)


#         if (final is not None)and(feature == False):
#             result = final
#             cv2.imshow("result", result)
#         elif (final is not None):
#             (result, vis) = final
#             cv2.imshow("result", result)
#         cv2.imshow("window", gx_img)
#         cv2.imshow("window2", hk_img)
#         cv2.waitKey(1)
        
#     except CvBridgeError as e:
#         rospy.logerr(f"Error converting images: {e}")

# if __name__ == '__main__':
#     try:
#         rospy.init_node('two_TOPIC', anonymous=True)
        
#         subcriber_gx = message_filters.Subscriber('/camera_image', Image)
#         subcriber_hk = message_filters.Subscriber('/camera/image', Image)
        
#         sync = message_filters.ApproximateTimeSynchronizer([subcriber_gx, subcriber_hk], 20, 0.05)
#         sync.registerCallback(multi_callback)

#         rospy.spin()
#     except rospy.ROSInterruptException:
#         pass
#     finally:
#         cv2.destroyAllWindows()


# img1 = None
# img2 = None


# stitcher = Stitcher()

# def image_callback_1(msg):
#     """
#     处理 /galaxy_camera/galaxy_camera/image_raw 话题的回调函数
#     """
#     rospy.loginfo("Received image from /galaxy_camera/galaxy_camera/image_raw")
#     global img1
#     try:
#         # 使用 cv_bridge 将 ROS 图像消息转换为 OpenCV 图像
#         bridge = CvBridge()
#         img1 = bridge.imgmsg_to_cv2(msg, "bgr8")
#     except Exception as e:
#         rospy.logerr("Error converting image from /galaxy_camera/galaxy_camera/image_raw: %s", str(e))


# def image_callback_2(msg):
#     """
#     处理 /camera/image 话题的回调函数
#     """
#     rospy.loginfo("Received image from /camera/image")
#     global img2
#     try:
#         # 使用 cv_bridge 将 ROS 图像消息转换为 OpenCV 图像
#         bridge = CvBridge()
#         img2 = bridge.imgmsg_to_cv2(msg, "bgr8")
#     except Exception as e:
#         rospy.logerr("Error converting image from /camera/image: %s", str(e))


# def multi_callback():
#     print ("同步完成！")


# def main():
#     try:
#         rospy.init_node('image_listener_node', anonymous=True)

#         # 订阅 /galaxy_camera/galaxy_camera/image_raw 话题
#         sub1 = rospy.Subscriber("/galaxy_camera/galaxy_camera/image_raw", Image, image_callback_1)
#         # 订阅 /camera/image 话题
#         sub2 = rospy.Subscriber("/camera/image", Image, image_callback_2)

#         rate = rospy.Rate(1)
#         while not rospy.is_shutdown():
#             if img1 is not None:
#                 cv2.imshow("Galaxy Camera Image", img1)
#                 cv2.waitKey(1000)
#             if img2 is not None:
#                 cv2.imshow("Camera Image", img2)
#                 cv2.waitKey(1000)
#             # (result, vis) = stitcher.stitch([img1, img2], showMatches=True)
#             # cv2.imshow("Result", result)
#             if (img1 is not None)and(img2 is not None):
#                 sync = message_filters.ApproximateTimeSynchronizer([sub1, sub2], 10,1)#同步时间戳，具体参数含义需要查看官方文档。
#                 sync.registerCallback(multi_callback)#执行反馈函数

                
#             key = cv2.waitKey(1) & 0xFF
#             if key == 27:
#                 break
#         rate.sleep()


#     except rospy.ROSInterruptException:
#         pass
#     finally:
#         # 关闭所有 OpenCV 窗口
#         cv2.destroyAllWindows()


# if __name__ == '__main__':
#     main()
#!/usr/bin/env python
# -*- coding: utf-8 -*-

# -*- coding: utf-8 -*-
